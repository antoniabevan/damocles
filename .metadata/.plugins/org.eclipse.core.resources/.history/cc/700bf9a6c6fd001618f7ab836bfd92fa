MODULE class_grid

    use globals
    use class_geometry
    use class_dust
    use class_freq_grid

    implicit none

    REAL                 ::  tot_vol                      !total volume of supernova in 1e42cm^3
    REAL,ALLOCATABLE     ::  shell_radius(:,:)            !radial bounds of each shell in 1e15cm
    REAL                 ::  const                        !scaling constant used in the calculation of the no of packets to be emitted per shell/cell

    TYPE grid_obj
        INTEGER          ::  n_cells(3)                   !number of cells in x/y/z directions
        INTEGER          ::  tot_cells                    !total number of cells
        REAL             ::  cell_vol                     !volume of grid cell (only applicable for cubic grids with equal no of divisions in each axis)
        REAL             ::  x_min,x_max                  !outer bounds of grid in x dimension
        REAL             ::  y_min,y_max                  !outer bounds of grid in y dimension
        REAL             ::  z_min,z_max                  !outer bounds of grid in z dimension
        REAL             ::  cell_width(3)                !width of grid cells in x/y/z directions (only applicable for cubic grids with equal no of divisions in each axis)
        REAL,ALLOCATABLE ::  x_div(:),y_div(:),z_div(:)   !locations of divisions listed consecutively in x, y and z
    END TYPE grid_obj

    TYPE(grid_obj)       ::  mothergrid                   !properties of the mothergrid

    TYPE grid_cell_obj
        REAL             ::  rho                          !mass density of grid cell
        REAL             ::  nrho                         !number density of grid cell
        REAL             ::  N_e                          !electron density of grid cell
        REAL             ::  r                            !radial distance from (0,0,0) to the centre of the cell
        REAL             ::  vol                          !volume of cell
        REAL             ::  axis(3)                      !limits of grid cell in x, y and z
        REAL             ::  width(3)                     !width of grid cells in x/y/z directions
        LOGICAL          ::  lg_clump                     !logical indicating whether or not grid cell is a clump
        INTEGER          ::  id(3)                        !grid cell number in each of x, y and z
    END TYPE

    TYPE(grid_cell_obj),ALLOCATABLE :: grid_cell(:)       !mothergrid is comprised of'tot_cells' grid_cells

    REAL,ALLOCATABLE                :: profile_array(:)
    INTEGER(8),ALLOCATABLE          :: num_packets_array(:)


    !!variables declared below need review (removing, moving, etc.)

    INTEGER(8)          ::  iP
    INTEGER(8)          ::  n
    INTEGER             ::  n_clumps                    !actual number of clumps used (increased over iterations
                                                        !until within 99.5% of theoretical number)
    INTEGER             ::  loop                        !loop counter for clump iterations

    REAL                ::  SF                          !scale factors used for normalising
    REAL                ::  m                           !calculated mass of dust using densities and vols to check correct
    REAL                ::  h,micm,mcl,prob,m_displaced
    REAL                ::  pp
    REAL                ::  rhodG
    REAL                ::  ndust
    REAL                ::  rho_in_icm                  !density at inner radius for dust not in clumps in smooth distribution
    REAL                ::  msub                        !mass in grid replaced by clumps
    REAL                ::  cellno
    REAL                ::  shell_width
    REAL                ::  lambda_bin

    REAL                ::  E_0
    REAL                ::  vel_bin
    REAL                ::  ndustav
    REAL,ALLOCATABLE    ::  tmp(:,:)


    CHARACTER(LEN=1024) :: junk


contains

    SUBROUTINE build_dust_grid()

        PRINT*, 'Constructing grid...'

        SELECT CASE(dust_geometry%type)

            CASE("shell")

                !open files to write gridcell coords to (in cm)
                OPEN(32,file='grid.in')

                !calculate R_max and R_min (dust) based on maximum velocity, day no (d=v*t) and R_min/R_max ratio
                dust_geometry%R_max=dust_geometry%v_max*day_no*8.64E-6
                dust_geometry%R_min=dust_geometry%R_ratio*dust_geometry%R_max

                !check Rin/Rout ratio
                IF (dust_geometry%R_min>dust_geometry%R_max) THEN
                    PRINT*, "Please specify an R_min/R_max ratio that is less than 1.  Aborted."
                    STOP
                END IF

                !convert supernova bounds from e15cm to cm
                dust_geometry%R_min_cm=dust_geometry%R_min*1e15
                dust_geometry%R_max_cm=dust_geometry%R_max*1e15

                !convert dust mass from M_sun to grams
                dust%mass_grams=dust%mass*1.98855e33

                !set bounds of grid to be radius of SN
                mothergrid%x_min=-1*MAX(dust_geometry%R_max_cm,gas_geometry%R_max*1e15)
                mothergrid%y_min=mothergrid%x_min
                mothergrid%z_min=mothergrid%x_min
                mothergrid%x_max=-mothergrid%x_min
                mothergrid%y_max=mothergrid%x_max
                mothergrid%z_max=mothergrid%x_max

                !set number of cells in each direction and calculate total number of cells
                !mothergrid%n_cells(1) read in from input file in input.f90
                !!edit here if different number of cells in each direction required
                mothergrid%n_cells(2)=mothergrid%n_cells(1)
                mothergrid%n_cells(3)=mothergrid%n_cells(1)
                mothergrid%tot_cells=mothergrid%n_cells(1)*mothergrid%n_cells(2)*mothergrid%n_cells(3)

                mothergrid%cell_width(1)=(mothergrid%x_max-mothergrid%x_min)/mothergrid%n_cells(1)
                mothergrid%cell_width(2)=(mothergrid%y_max-mothergrid%y_min)/mothergrid%n_cells(2)
                mothergrid%cell_width(3)=(mothergrid%z_max-mothergrid%z_min)/mothergrid%n_cells(3)
                mothergrid%cell_vol=((mothergrid%cell_width(1)/1e14)*(mothergrid%cell_width(2)/1e14)*(mothergrid%cell_width(3)/1e14)) !in 1e42cm^3

                !calculate total volume of shell in 1e42cm^3
                tot_vol=1000*4*pi*(dust_geometry%R_max**3-dust_geometry%R_min**3)/3 !in e42cm^3

                ALLOCATE(grid_cell(mothergrid%tot_cells))
                ALLOCATE(mothergrid%x_div(mothergrid%n_cells(1)))
                ALLOCATE(mothergrid%y_div(mothergrid%n_cells(2)))
                ALLOCATE(mothergrid%z_div(mothergrid%n_cells(3)))

                !for a cubic grid (as for a shell), set the cell widths and volumes to be identical for all cells
                grid_cell%width(1)=mothergrid%cell_width(1)
                grid_cell%width(2)=mothergrid%cell_width(2)
                grid_cell%width(3)=mothergrid%cell_width(3)
                grid_cell%vol=mothergrid%cell_vol

                !initialise mothergrid divisions to zero
                mothergrid%x_div=0
                mothergrid%y_div=0
                mothergrid%z_div=0

                !calculate divisions in mothergrid in each axis (grid cell coordinates)
                DO ixx=1,mothergrid%n_cells(1)
                    mothergrid%x_div(ixx)=mothergrid%x_min+((ixx-1)*mothergrid%cell_width(1))
                END DO

                DO iyy=1,mothergrid%n_cells(2)
                    mothergrid%y_div(iyy)=mothergrid%y_min+((iyy-1)*mothergrid%cell_width(2))
                END DO

                DO izz=1,mothergrid%n_cells(3)
                    mothergrid%z_div(izz)=mothergrid%z_min+((izz-1)*mothergrid%cell_width(3))
                END DO

                !calculate radius of the centre of each cell
                iG=0
                grid_cell%r=0
                DO ixx=1,mothergrid%n_cells(1)
                    DO iyy=1,mothergrid%n_cells(2)
                        DO izz=1,mothergrid%n_cells(3)
                            iG=iG+1
                            grid_cell(iG)%r=((mothergrid%x_div(ixx)+mothergrid%cell_width(1)/2)**2+(mothergrid%y_div(iyy)+mothergrid%cell_width(2)/2)**2+(mothergrid%z_div(izz)+mothergrid%cell_width(3)/2)**2)**0.5
                            grid_cell(iG)%axis(:)=(/ mothergrid%x_div(ixx),mothergrid%y_div(iyy),mothergrid%z_div(izz)/)
                        END DO
                    END DO
                END DO

                !!!!!!!!!!!!!!!!!!!!!!!!!
                !initialise everything to 0
                n_clumps=0
                m=0
                micm=0
                mcl=0
                prob=0
                pp=0
                rhodG=0
                ndust=0
                iG=0
                SF=0
                n=0
                iG=0
                h=0.
                ndustav=0.
                !!!!!!!!!!!!!!!!!!!!!!!!

                !calculate desired mass of dust in clumps and in interclump medium (icm)
                dust%m_icm=dust%mass*(1-dust_geometry%clumped_mass_frac)

                !calculate number of clumps based on filling fraction of total volume and volume of clump (=volume of grid cell)
                dust_geometry%n_clumps=FLOOR(dust_geometry%ff*tot_vol/mothergrid%cell_vol)

                !calculate mass of a clump based on dust mass fraction in clumps and total number of clumps
                dust%m_clump=(dust%mass*dust_geometry%clumped_mass_frac)/dust_geometry%n_clumps

                !calculate density of a clump based on mass of clump and volume of clump
                !5.02765e8=1e42/1.989e33 i.e. conversion factor for  e42cm3 to cm3 and g to Msun)
                dust_geometry%rho_clump=dust%m_clump/(mothergrid%cell_vol*5.02765e8)

!!!
                grid_cell(:)%lg_clump=.false.
                prob=0
                msub=0
                n_clumps=0
                h=0

                SF=((dust_geometry%R_max**(1-dust_geometry%clump_power)-dust_geometry%R_min**(1-dust_geometry%clump_power)))/(dust_geometry%R_min**(-dust_geometry%clump_power)*(1-dust_geometry%clump_power))

                                    !calculate dust density at inner radius (rho_in)
                    !factor of 1.989e-12 (= 1.989e33/1e45) to convert from Msun/e45cm3 to g/cm3
                    IF (dust_geometry%rho_power==3) THEN
                        dust_geometry%rho_in=(dust_geometry%R_min**(-dust_geometry%rho_power))*((dust%mass*1.989e33)/(LOG(dust_geometry%R_max/dust_geometry%R_min)*4*pi))
                        dust_geometry%rho_in=dust_geometry%rho_in*(1.989e-12)
                    ELSE
                        dust_geometry%rho_in=(dust_geometry%R_min**(-dust_geometry%rho_power))*((dust%mass*(3-dust_geometry%rho_power)) &
                            & /(4*pi*(dust_geometry%R_max**(3-dust_geometry%rho_power)-dust_geometry%R_min**(3-dust_geometry%rho_power))))
                        dust_geometry%rho_in=dust_geometry%rho_in*(1.989e-12)
                    END IF

                IF (dust_geometry%lg_clumped) THEN

!                    !calculate dust density at inner radius (rho_in_icm) for smooth interclump medium (excluding clumps)
!                    IF (dust_geometry%rho_power==3) THEN
!                        !!check the factor of 1+ff...???
!                        !                        rho_in_icm=dust_geometry%R_min**(-dust_geometry%rho_power)*(1+dust_geometry%ff)*((dust%m_icm)/(LOG(dust_geometry%R_max/dust_geometry%R_min)*4*pi))
!                        rho_in_icm=(dust%m_icm*dust_geometry%R_min**(-dust_geometry%rho_power))/(4*pi*(1-dust_geometry%ff)*LOG(dust_geometry%R_max/dust_geometry%R_min))
!                        rho_in_icm=rho_in_icm*1.989e-12
!                    ELSE
!                        rho_in_icm=dust_geometry%R_min**(-dust_geometry%rho_power)*(1+dust_geometry%ff)*((dust%m_icm)*(3-dust_geometry%rho_power) &
!                            & /(4*pi*(dust_geometry%R_max**(3-dust_geometry%rho_power)-dust_geometry%R_min**(3-dust_geometry%rho_power))))
!                        !rho_in_icm=dust_geometry%R_min**(-dust_geometry%rho_power)*((dust%m_icm)*(3-dust_geometry%rho_power) &
!                        !    & /(4*pi*(dust_geometry%ff)*(dust_geometry%R_max**(3-dust_geometry%rho_power)-dust_geometry%R_min**(3-dust_geometry%rho_power))))
!                        rho_in_icm=rho_in_icm*1.989e-12
!                    END IF

                    !repeat until required number of clumps reached
                    DO WHILE (n_clumps<(dust_geometry%n_clumps))
                        !select a random cell from the grid
                        call RANDOM_NUMBER(cellno)
                        iG=ceiling(mothergrid%tot_cells*cellno)
                        IF (iG==0) CYCLE

                        !test cell against clump probability distribution
                        IF ( (grid_cell(iG)%r<(dust_geometry%R_max_cm)) .AND. &
                           & (grid_cell(iG)%r>(dust_geometry%R_min_cm)) .AND. &
                           & (.not. grid_cell(iG)%lg_clump)) THEN
                            h=h+1
                            prob=((dust_geometry%R_min_cm/grid_cell(iG)%r)**dust_geometry%clump_power)

                            call RANDOM_NUMBER(pp)
                            IF (pp<prob) THEN
                                grid_cell(iG)%lg_clump=.true.
                                n_clumps=n_clumps+1
                                rhodG=dust_geometry%rho_clump
                                mcl=mcl+rhodG*mothergrid%cell_vol*5.02765e8
                                msub=msub+(mothergrid%cell_vol*5.02765e8*rho_in_icm*(dust_geometry%R_min_cm/grid_cell(iG)%r)**dust_geometry%rho_power)
                                m_displaced=m_displaced+((dust_geometry%rho_in)*(dust_geometry%R_min_cm/grid_cell(iG)%r)**dust_geometry%rho_power)
                            END IF
                        END IF
                    END DO


                    PRINT*,'average mass density (including clumps) (g/cm3)',(dust%mass_grams*1e-14)/(tot_vol*1e28)
                    PRINT*,'icm mass density at inner radius (g/cm3)',rho_in_icm
                    PRINT*,'icm mass density at outer radius (g/cm3)',(rho_in_icm)*(dust_geometry%R_min/dust_geometry%R_max)**dust_geometry%rho_power
                    PRINT*,'mass of interclump medium (Msun)',dust%m_icm
                    PRINT*,'mass in clumps (Msun)',dust%m_clump*dust_geometry%n_clumps
                    PRINT*,'density constrast',dust_geometry%den_con

                    iG=0
                    h=0
                    m=0
                    micm=0
                    DO ixx=1,mothergrid%n_cells(1)
                        DO iyy=1,mothergrid%n_cells(2)
                            DO izz=1,mothergrid%n_cells(3)
                                iG=iG+1

                                IF ((grid_cell(iG)%r<(dust_geometry%R_max_cm)) .AND. (grid_cell(iG)%r>(dust_geometry%R_min_cm))) THEN
                                    h=h+1
                                    IF (.not. grid_cell(iG)%lg_clump) THEN
                                        rhodG=rho_in_icm*(dust_geometry%R_min_cm/grid_cell(iG)%r)**dust_geometry%rho_power
                                        micm=micm+rhodG*mothergrid%cell_vol*5.02765e8
                                        loop=loop+1
                                    END IF
                                    m=m+rhodG*mothergrid%cell_vol*5.02765e8
                                    ndust=rhodG/dust%av_mgrain
                                    ndustav=ndustav+ndust

                                    grid_cell(iG)%rho=rhodG
                                    grid_cell(iG)%nrho= ndust
                                    WRITE(32,*) grid_cell(iG)%axis(:),grid_cell(iG)%rho
                                    !!!when looking at clumping need to include ES
                                    grid_cell(ig)%id(:)=(/ ixx,iyy,izz /)
                                    !this should be equal to numpG not 0 but I've left out the calculation...
                                ELSE
                                    grid_cell(iG)%axis(:)=(/ mothergrid%x_div(ixx),mothergrid%y_div(iyy),mothergrid%z_div(izz)/)
                                    grid_cell(iG)%rho=0.
                                    grid_cell(iG)%nrho=0
                                    grid_cell(ig)%id(:)=(/ ixx,iyy,izz /)
                                    !WRITE(32,*) mgrid(ig)%id(:),mgrid(iG)%numPhots,mgrid(iG)%axis(:),mgrid(iG)%rho,mgrid(iG)%nrho
                                END IF
                            END DO
                        END DO
                    END DO

                ELSE
                    !not clumping


                    h=0
                    DO ixx=1,mothergrid%n_cells(1)
                        DO iyy=1,mothergrid%n_cells(2)
                            DO izz=1,mothergrid%n_cells(3)
                                iG=iG+1
                                IF ((grid_cell(iG)%r<(dust_geometry%R_max_cm)) .AND. (grid_cell(iG)%r>(dust_geometry%R_min_cm))) THEN
                                    h=h+1
                                    rhodG=((dust_geometry%rho_in)*(dust_geometry%R_min_cm/grid_cell(iG)%r)**dust_geometry%rho_power)
                                    m=m+rhodG*mothergrid%cell_vol*5.02765e8         !5.02765e8=1e42/1.989e33 i.e. conversion factor for  e42cm3 to cm3 and g to Msun
                                    ndust=rhodG/dust%av_mgrain
                                    ndustav=ndustav+ndust
                                    grid_cell(iG)%axis(:)=(/ mothergrid%x_div(ixx),mothergrid%y_div(iyy),mothergrid%z_div(izz)/)
                                    grid_cell(iG)%rho=rhodG
                                    grid_cell(iG)%nrho= ndust
                                    grid_cell(ig)%id(:)=(/ ixx,iyy,izz /)
                                ELSE
                                    grid_cell(iG)%axis(:)=(/ mothergrid%x_div(ixx),mothergrid%y_div(iyy),mothergrid%z_div(izz)/)
                                    grid_cell(iG)%rho=0.
                                    grid_cell(iG)%nrho=0
                                    grid_cell(ii)%N_e=0
                                    grid_cell(ig)%id(:)=(/ ixx,iyy,izz /)
                                    !WRITE(32,*) mgrid(ig)%id(:),mgrid(iG)%numPhots,mgrid(iG)%axis(:),mgrid(iG)%rho,mgrid(iG)%nrho
                                END IF
                                WRITE(32,*) grid_cell(iG)%axis(:),grid_cell(iG)%rho
                            END DO
                        END DO
                    END DO
                    PRINT*,'DUST GRAIN NUMBER DENSITY AT Rin',dust_geometry%rho_in/dust%av_mgrain
                    PRINT*,'DUST GRAIN NUMBER DENSITY AT Rout',((dust_geometry%rho_in)*(dust_geometry%R_min_cm/dust_geometry%R_max_cm)**dust_geometry%rho_power)/dust%av_mgrain
                END IF

                CLOSE(32)

            CASE("torus")
                PRINT*, 'You have selected a torus distribution of dust.  This routine has not been written yet.  &
                & It is due to be added to the class_grid module in due course.'
                WRITE(55,*) 'You have specified a torus distribution of dust.  Damocles is not yet capable of creating this grid.  &
                & It is due to be added to the class_grid module.  Aborted.'
                STOP
            CASE("arbitrary")
                !read in dust grid file
                !!note that currently the filename is hard coded and should be changed to be variable
                OPEN(33,file='dust_grid.in')

                !the file format is based on the grid generated by the mocassin grid generator which can be found at
                !http://www.nebulousresearch.org/codes/mocassin/mocassin_gridmaker.php
                !additional first line declaring maximum velocity and maximum radius (at which maximum velocity occurs)
                !read in maximum velocity and radius at which maximum velocity occurs
                READ(33,*) dust_geometry%v_max,dust_geometry%R_max,dust_geometry%v_power
                READ(33,*) junk,mothergrid%n_cells(1),mothergrid%n_cells(2),mothergrid%n_cells(3)
                mothergrid%tot_cells=mothergrid%n_cells(1)*mothergrid%n_cells(2)*mothergrid%n_cells(3)

                ALLOCATE(grid_cell(mothergrid%tot_cells))
                ALLOCATE(mothergrid%x_div(mothergrid%n_cells(1)))
                ALLOCATE(mothergrid%y_div(mothergrid%n_cells(2)))
                ALLOCATE(mothergrid%z_div(mothergrid%n_cells(3)))


                xx=0
                yy=0
                zz=0
                !grid must be arranged in ascending z, then y, then x (as per mocassin grid maker)
                !!include a sort here to ensure this is the case?
                DO iG=1,mothergrid%tot_cells

                    !read in limits of grid cells in x, y and z
                    READ(33,*) grid_cell(iG)%axis(1),grid_cell(iG)%axis(2),grid_cell(iG)%axis(3),grid_cell(iG)%nrho

                    !this section calculates the cell no in each axis given the overall cell number within the grid
                    !(effectively reverse engineers iG=(n_cells(2)*n_cells(3)*(id(1)-1)+n_cells(3)*(id(2)-1)+id(3)))
                    IF (MOD(iG,mothergrid%n_cells(3)) /=1) THEN
                        grid_cell(iG)%id(3)=grid_cell(iG-1)%id(3)+1
                    ELSE
                        grid_cell(iG)%id(3)=1
                    END IF
                    grid_cell(iG)%id(2)=MOD((iG-grid_cell(iG)%id(3))/mothergrid%n_cells(3),mothergrid%n_cells(2))+1
                    grid_cell(iG)%id(1)=((iG-grid_cell(iG)%id(3)-(mothergrid%n_cells(3)*(grid_cell(iG)%id(2)-1)))/(mothergrid%n_cells(3)*mothergrid%n_cells(2)))+1

                    !this section populates the list of divisions in x, y and z from the grid specified
                    !each time a cell is encountered where the id of the other two axes is 1, the third non-zero axis is stored
                    !this generates a unique list of axis divisions
                    IF (grid_cell(iG)%id(1) == 1 .and. grid_cell(iG)%id(2) == 1) THEN
                        zz=zz+1
                        mothergrid%z_div(zz)=grid_cell(iG)%axis(3)
                    END IF
                    IF (grid_cell(iG)%id(1) == 1 .and. grid_cell(iG)%id(3) == 1) THEN
                        yy=yy+1
                        mothergrid%y_div(yy)=grid_cell(iG)%axis(2)
                    END IF
                    IF (grid_cell(iG)%id(2) == 1 .and. grid_cell(iG)%id(3) == 1) THEN
                        xx=xx+1
                        mothergrid%x_div(xx)=grid_cell(iG)%axis(1)
                    END IF
                END DO

                CLOSE(33)

                !radii are calculated for each grid cell from the centre of the grid (0,0,0) to the centre of the cell
                !volumes are calculated by multiplying distance to next division in all axes
                !at far 'right' edge, the volumes, widths and radii are calculated using symmetries of grid
                !i.e. radius/volume at cell (43,47,50) is same as for (43,47,1)
                DO iG=1,mothergrid%tot_cells
                    IF (grid_cell(iG)%id(1) /= mothergrid%n_cells(1) .and. &
                        & grid_cell(iG)%id(2) /= mothergrid%n_cells(2) .and. &
                        & grid_cell(iG)%id(3) /= mothergrid%n_cells(3)) THEN

                        grid_cell(iG)%r=((((grid_cell(iG)%axis(1)+grid_cell(iG+1)%axis(1))/2)**2) + &
                            & (((grid_cell(iG)%axis(2)+grid_cell(iG+1)%axis(2))/2)**2) + &
                            & (((grid_cell(iG)%axis(3)+grid_cell(iG+1)%axis(3))/2)**2))**0.5
                        grid_cell(iG)%vol=(mothergrid%x_div(grid_cell(iG)%id(1)+1)-mothergrid%x_div(grid_cell(iG)%id(1)))*1e-14* &
                            & (mothergrid%y_div(grid_cell(iG)%id(2)+1)-mothergrid%y_div(grid_cell(iG)%id(2)))*1e-14* &
                            & (mothergrid%z_div(grid_cell(iG)%id(3)+1)-mothergrid%z_div(grid_cell(iG)%id(3)))*1e-14
                        grid_cell(iG)%width(1)=mothergrid%x_div(grid_cell(iG)%id(1)+1)-mothergrid%x_div(grid_cell(iG)%id(1))
                        grid_cell(iG)%width(2)=mothergrid%x_div(grid_cell(iG)%id(2)+1)-mothergrid%x_div(grid_cell(iG)%id(2))
                        grid_cell(iG)%width(3)=mothergrid%x_div(grid_cell(iG)%id(3)+1)-mothergrid%x_div(grid_cell(iG)%id(3))
                    ELSE IF (grid_cell(iG)%id(3) == mothergrid%n_cells(3)) THEN
                        grid_cell(iG)%vol=grid_cell(iG-mothergrid%n_cells(3)+1)%vol
                        grid_cell(iG)%r=grid_cell(iG-mothergrid%n_cells(3)+1)%r
                        grid_cell(iG)%width=grid_cell(iG-mothergrid%n_cells(3)+1)%width
                    ELSE IF (grid_cell(iG)%id(2) == mothergrid%n_cells(2)) THEN
                        grid_cell(iG)%vol=grid_cell(iG-mothergrid%n_cells(2)*(grid_cell(iG)%id(2)-1))%vol
                        grid_cell(iG)%r=grid_cell(iG-mothergrid%n_cells(2)*(grid_cell(iG)%id(2)-1))%r
                        grid_cell(iG)%width=grid_cell(iG-mothergrid%n_cells(2)*(grid_cell(iG)%id(2)-1))%width
                    ELSE IF (grid_cell(iG)%id(1) == mothergrid%n_cells(1)) THEN
                        grid_cell(iG)%vol=grid_cell(iG-mothergrid%n_cells(2)*mothergrid%n_cells(1)*(grid_cell(iG)%id(1)-1))%vol
                        grid_cell(iG)%r=grid_cell(iG-mothergrid%n_cells(2)*mothergrid%n_cells(1)*(grid_cell(iG)%id(1)-1))%r
                        grid_cell(iG)%width=grid_cell(iG-mothergrid%n_cells(2)*mothergrid%n_cells(1)*(grid_cell(iG)%id(1)-1))%width
                    END IF
                END DO

                PRINT*,'Dust mass in grid (Msun)',sum(grid_cell(:)%nrho*(grid_cell(:)%vol)*dust%av_mgrain)*5.02765e8         !5.02765e8=1e42/1.989e33 i.e. conversion factor for  e42cm3 to cm3 and g to Msun)

            CASE("bipolar")
                PRINT*, 'You have selected a bipolar distribution of dust.  This routine has not been written yet.  &
                & It is due to be added to the class_grid module in due course.'
                WRITE(55,*) 'You have specified a bipolar distribution of dust.  Damocles is not yet capable of creating this grid.  &
                & It is due to be added to the class_grid module.  Aborted.'
                STOP
            CASE DEFAULT
                PRINT*, 'Please specify one of the following options for the geometry "shell", "torus", "arbitrary" or "bipolar". Aborted.'
                WRITE(55,*) 'Aborted - dust geometry option was not one of "shell", "torus", "arbitrary" or "bipolar".'
                STOP
        END SELECT

    END SUBROUTINE

    SUBROUTINE build_emissivity_dist()

        PRINT*,'Building emissivity distribution...'

        ALLOCATE(profile_array(nu_grid%n_bins))
        ALLOCATE(tmp(nu_grid%n_bins,1))
        tmp=0
        profile_array=0
        SELECT CASE(gas_geometry%type)

            CASE("shell")
                !assign parameters related to gas geometry
                IF (lg_decoupled) THEN
                    !if decoupled then generate max/min radii from epoch and maximum velocity
                    gas_geometry%R_max=gas_geometry%v_max*day_no*8.64E-6
                    gas_geometry%R_min=gas_geometry%R_ratio*gas_geometry%R_max
                ELSE
                    !if decoupled then set gas geometry parameters to equal the dust geometry parameters
                    IF (gas_geometry%type /= dust_geometry%type) THEN
                        PRINT*, 'You have requested that gas and dust distributions be coupled but specified different geometries.  Aborted.'
                        STOP
                    END IF
                    gas_geometry%R_ratio=dust_geometry%R_ratio
                    gas_geometry%R_min=dust_geometry%R_min
                    gas_geometry%R_max=dust_geometry%R_max
                    gas_geometry%v_power=dust_geometry%v_power
                    gas_geometry%rho_power=dust_geometry%rho_power
                    gas_geometry%emis_power=dust_geometry%emis_power
                    gas_geometry%v_max=dust_geometry%v_max
                END IF

                !allocate memory for array to store number of packets to be emitted in each cell/shell
                IF (gas_geometry%clumped_mass_frac /= 1) THEN
                    ALLOCATE(num_packets_array(n_shells+1))
                    ALLOCATE(shell_radius(n_shells+1,2))
                ELSE IF (gas_geometry%clumped_mass_frac == 1) THEN
                    ALLOCATE(num_packets_array(mothergrid%tot_cells))
                END IF

                !calculate upper and lower radius bound for each shell and shell width
                shell_width=(gas_geometry%R_max-gas_geometry%R_min)/n_shells
                shell_radius(1,1)=gas_geometry%R_min
                shell_radius(1,2)=gas_geometry%R_min+shell_width

                DO ii=1,n_shells
                    shell_radius(ii+1,1:2)=(/ shell_radius(ii,2),shell_radius(ii,2)+shell_width /)
                END DO

                !calculate number of packets in each shell
                IF ((gas_geometry%emis_power*gas_geometry%rho_power)==3) THEN
                    const=n_packets/(LOG(gas_geometry%R_max/gas_geometry%R_min))
                    num_packets_array(:)=NINT(const*LOG(shell_radius(:,2)/shell_radius(:,1)))
                ELSE
                    const=n_packets*(gas_geometry%emis_power*gas_geometry%rho_power-3)/(gas_geometry%R_min**(3-gas_geometry%emis_power*gas_geometry%rho_power)-gas_geometry%R_max**(3-gas_geometry%emis_power*gas_geometry%rho_power))
                    num_packets_array(:)=NINT(const*(shell_radius(:,1)**(3-gas_geometry%emis_power*gas_geometry%rho_power)-shell_radius(:,2)**(3-gas_geometry%emis_power*gas_geometry%rho_power))/(gas_geometry%emis_power*gas_geometry%rho_power-3))
                END IF

            CASE("torus")
                IF (lg_decoupled) THEN
                    PRINT*, 'You have selected a torus distribution of gas.  This routine has not been written yet.  &
                & It is due to be added to the class_grid module in due course.'
                    WRITE(55,*) 'You have specified a torus distribution of gas.  Damocles is not yet capable of creating this grid.  &
                & It is due to be added to the class_grid module.  Aborted.'
                    STOP
                END IF
            CASE("arbitrary")

                IF (lg_decoupled) THEN
                    PRINT*,"Haven't yet included provision for two different arbitrary distributions of dust and gas. Aborted."
                    STOP
                ELSE
                    ALLOCATE(num_packets_array(mothergrid%tot_cells))
                    num_packets_array=0
                    PRINT*,'Calculating number of packets to be emitted in each cell...'
                    !number of packets to be emitted in each cell scaled with square of number density of particles in cell
                    num_packets_array(:)=NINT((grid_cell(:)%nrho**2)*real(n_packets)*(grid_cell(ii)%vol/SUM((grid_cell%nrho**2)*(grid_cell%vol))))
                    gas_geometry%v_max=dust_geometry%v_max
                    gas_geometry%R_max=dust_geometry%R_max
                    gas_geometry%v_power=dust_geometry%v_power
                    gas_geometry%R_max_cm=gas_geometry%R_max*1e15
                END IF

            CASE("bipolar")
                IF (lg_decoupled) THEN
                    PRINT*, 'You have selected a bipolar distribution of gas.  This routine has not been written yet.  &
                & It is due to be added to the class_grid module in due course.'
                    WRITE(55,*) 'You have specified a bipolar distribution of gas.  Damocles is not yet capable of creating this grid.  &
                & It is due to be added to the class_grid module.  Aborted.'

                    STOP
                END IF
            CASE DEFAULT
                IF (lg_decoupled) THEN
                    PRINT*, 'Please specify one of the following options for the geometry "shell", "torus", "arbitrary" or "bipolar". Aborted.'
                    WRITE(55,*) 'Aborted - dust geometry option was not one of "shell", "torus", "arbitrary" or "bipolar".'
                    STOP
                END IF
        END SELECT


    END SUBROUTINE build_emissivity_dist

END MODULE class_grid
